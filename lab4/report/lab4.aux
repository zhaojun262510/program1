\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}实验要求}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}学习调试及性能分析}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}初步了解元编程，学习大杂烩里的内容}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}初步学会pytorch的使用}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}完成与学习内容相关的4个课堂练习与20个实例}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {2}实验内容}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}调试代码}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.1}打印调试法和日志：\\1.打印调试法：最简单的调试方式，通过在代码中的关键位置打印变量值、状态信息，来了解程序执行流程和错误原因。适合初期排查问题，缺点是容易让代码凌乱。\\2.日志（Logging）：比打印更为系统化的调试方法，允许根据不同的严重性（如DEBUG、INFO、WARNING、ERROR等）记录程序执行的详细信息。日志可以持久化保存，方便回溯问题。\\3.Python的logging模块是常用的日志库，允许开发者根据需求动态设置日志的级别、格式、输出目的（如文件、控制台）。}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.2}第三方日志系统：\\1.Logstash、Fluentd：这些系统用于收集、处理和存储日志。它们允许从多个来源收集日志，并支持过滤、转换和发送日志到存储系统。\\2.ELK Stack（Elasticsearch, Logstash, Kibana）：一个流行的日志分析平台，提供了日志聚合、搜索和可视化功能。Kibana可帮助开发者直观地分析日志信息，发现异常模式。}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.3}调试器：提供实时控制代码执行的工具，允许设置断点、查看和修改运行时变量、逐步执行代码等。\\GDB：一个常用的C/C++调试器，允许检查代码的内存、寄存器状态等。\\PDB：Python的标准调试器，允许在交互式命令行中调试Python代码。\\IDE集成调试器：大部分IDE（如PyCharm、VSCode）都有内置调试器，支持图形化界面下的断点、变量查看等功能。}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.4}静态分析：通过分析源代码而不执行程序来发现代码中的错误、潜在问题或优化机会。\\Pylint、Flake8：Python中的静态分析工具，可以检查代码风格、潜在错误、复杂度等问题。\\Clang Static Analyzer：C/C++代码的静态分析工具，可以检测内存泄漏、未定义行为等问题。\\SonarQube：支持多种语言的静态代码分析平台，集成了代码质量检测和技术债务管理。}{2}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}性能分析}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.1}手动计时：通过记录开始和结束时间来测量某个代码片段的运行时间。\\1.Python的time模块和timeit库都可以帮助精确测量代码段的执行时间。\\2.timeit特别适用于评估小代码段的性能，它自动管理计时和重复运行测试。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.2}性能分析工具Profiling：通过分析程序运行过程中的资源使用情况（如CPU、内存）来找出性能瓶颈。\\cProfile：Python自带的性能分析工具，记录每个函数调用的次数和执行时间，帮助找出性能热点。\\Py-Spy：一个性能监控工具，不影响程序的正常运行，适合对生产环境中的Python应用进行性能分析。\\Valgrind：用于C/C++程序的性能分析工具，可以检测内存泄漏、缓存未命中等问题。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.3}事件驱动的性能分析：一些性能问题只能在特定事件发生时暴露。通过记录系统或程序中的事件流，可以找到特定的性能瓶颈。\\性能可视化：通过图形化工具展示性能分析的结果，更容易找出性能瓶颈。\\资源监控：监控程序运行时的CPU、内存、磁盘I/O、网络等资源的使用情况，帮助评估系统性能。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.2.4}通过这些调试和性能分析的方法与工具，可以全面分析代码质量、资源使用情况，从而提高系统的稳定性和效率。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}元编程}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.1}元编程（Metaprogramming）通常被理解为编写能够操作或生成其他代码的代码，在本课中更多指的是开发流程中的自动化和管理，包括构建系统、代码测试以及依赖管理。这类元编程的目标是让开发流程更加高效、自动化，减少人工干预和重复劳动。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.2}构建系统的主要任务是将源代码转换为可执行程序或其他可交付的输出（如库、文档等）。它自动处理编译、链接、打包、测试和发布等流程，减少人为操作。\\关键功能：编译代码、管理依赖、任务自动化、增量构建\\常见的构建工具：Make、CMake、Maven等}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.3}代码测试在软件开发过程中至关重要，它通过自动化的测试流程保证代码的正确性、健壮性和可维护性。元编程在测试中的主要作用是自动化测试的执行、结果收集、分析以及集成测试的管理。\\测试的类型：\\单元测试（Unit Testing）：测试代码中的最小功能单位，通常是函数或类的测试。\\集成测试（Integration Testing）：测试不同模块或服务之间的交互，确保它们能正确协同工作。\\端到端测试（End-to-End Testing）：从用户视角出发，测试整个系统的功能，模拟用户的操作流程。\\回归测试（Regression Testing）：在代码更新后，确保新增或修改的代码没有引入新的错误。}{3}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.3.4}依赖管理用于确保项目中的外部库、工具和其他依赖项被正确地下载、安装和使用。有效的依赖管理工具能避免依赖冲突、版本不一致等问题，并自动处理依赖的升级和发布。\\依赖管理的核心内容：依赖声明：开发者通过配置文件或声明语法描述项目所依赖的库及其版本。\\版本控制：依赖管理工具会根据依赖声明下载对应版本的库，并确保项目使用兼容的版本。\\依赖冲突解决：当不同依赖项之间存在版本冲突时，依赖管理工具会自动选择合适的版本或提供冲突解决方案。\\缓存与镜像：通过本地缓存或镜像服务器加速依赖的下载和安装过程。}{4}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}PyTorch}{4}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.4.1}PyTorch是一个由 Facebook AI Research (FAIR) 团队开发的开源深度学习框架，专注于灵活的模型定义、易用性和高效的自动求导系统。它在学术界和工业界广泛使用，特别是在计算机视觉、自然语言处理等领域。PyTorch 的核心特性包括动态计算图、GPU加速、自动微分，以及一个功能丰富的生态系统，涵盖从研究到生产的深度学习工作流。}{4}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.4.2}PyTorch的核心特性：\\1.动态计算图：PyTorch 使用动态计算图，即模型的计算图在每次前向传播时即时构建。这种方式称为“Define-by-Run”，允许用户根据输入数据动态修改模型结构，非常适合调试和灵活构建复杂的神经网络。\\2.自动微分：PyTorch 提供了强大的自动微分功能，支持通过后向传播自动计算梯度。这是通过 autograd 模块实现的，它会记录每个操作，构建计算图，并根据需要进行梯度计算。\\3.张量计算与GPU加速：PyTorch 的核心是对张量（Tensor）的高效操作，张量是多维数组，类似于 NumPy 中的 ndarray。PyTorch 的张量可以在 GPU 上加速执行，借助 GPU 的并行计算能力，大大提高深度学习模型的训练速度。}{4}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.4.3}PyTorch的基本组件：\\1.Tensor张量：张量是 PyTorch 的核心数据结构，它类似于 NumPy 的多维数组，但可以在 GPU 上执行高效的并行计算。张量的操作包括基本的数值运算、线性代数、矩阵运算等。\\2.神经网络：torch.nn 模块提供了构建神经网络的基本构件，如层（Layer）、损失函数（Loss Function）、激活函数（Activation Function）等。PyTorch 的模块化设计允许用户轻松构建、组合和训练复杂的神经网络模型。\\3.优化器：优化器模块负责更新模型的参数，以最小化损失函数。PyTorch 提供了多种优化算法的实现，如随机梯度下降（SGD）、Adam、RMSprop 等。}{4}{}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {3}实验中遇到的问题与解决方法}{5}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}已安装Pytorch，却提示no moudle named ‘torch’}{5}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}pycharm配置anaconda环境时找不到python.exe}{5}{}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {4}实例练习}{6}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}向系统日志中写日志并读取}{6}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Python中使用日志记录调试}{6}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}性能分析之手动计时}{7}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.4}使用cProfile进行性能分析}{7}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.5}Markdown标题}{8}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.6}Markdown字体}{8}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.7}Markdown无序列表}{9}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.8}Markdown代码块}{9}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.9}Markdown实现矩阵}{10}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.10}创建和操作张量}{10}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.11}使用自动微分}{11}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.12}构建简单的线性模型}{11}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.13}训练一个简单的线性模型}{12}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.14}使用torch.nn.functional}{13}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.15}简单的线性回归}{14}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.16}数据加载与批处理}{15}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.17}简单的逻辑回归（二分类）}{15}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.18}简单的多分类问题}{16}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.19}简易自定义神经网络层}{18}{}\protected@file@percent }
\@writefile{toc}{\contentsline {subsection}{\numberline {4.20}使用批归一化}{18}{}\protected@file@percent }
\@writefile{toc}{\contentsline {section}{\numberline {5}实验收获与感悟}{19}{}\protected@file@percent }
\gdef \@abspage@last{20}
